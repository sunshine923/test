<div class="a1"> <h1>基础</h1> </div> <div class="a2"> <h2>命名视图</h2> <p>有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar（侧导航） 和 main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。</p> <pre><code class="lang-">&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt; &lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt; </code></pre> <p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置（带上 s）：</p> <pre><code class="lang-const"> routes: [ { path: '/', components: { default: Foo, a: Bar, b: Baz } } ] }) </code></pre> </div> <div class="a3"> <h2>html5 history模式</h2> <p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p> <p>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p> <pre><code class="lang-">const router = new VueRouter({ mode: 'history', routes: [...] }) </code></pre> <p>当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，也好看！</p> <p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。</p> <p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p> </div> <div class="a4"> <h1>过渡&amp;动画</h1> </div> <div class="a5"> <h2>进入/离开 &amp; 列表过渡</h2> <h3>单元素/组件的过渡</h3> <p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡</p> <p>条件渲染 (使用 v-if)<br /> 条件展示 (使用 v-show)<br /> 动态组件<br /> 组件根节点<br /> 这里是一个典型的例子：</p> <pre><code class="lang-">&lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; new Vue({ el: '#demo', data: { show: true } }) .fade-enter-active, .fade-leave-active { transition: opacity .5s } .fade-enter, .fade-leave-to /* .fade-leave-active in below version 2.1.8 */ { opacity: 0 } </code></pre> <h3>过渡的类名</h3> <p>在进入/离开的过渡中，会有 6 个 class 切换。<br /> v-enter：定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</p> <p>v-enter-active：定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</p> <p>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效 (与此同时 v-enter 被删除)，在 transition/animation 完成之后移除。</p> <p>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</p> <p>v-leave-active：定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</p> <p>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效 (与此同时 v-leave 被删除)，在 transition/animation 完成之后移除。</p> </div> <div class="a6"> <h2>状态过渡</h2> <p>Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如：</p> <p>数字和运算<br /> 颜色的显示<br /> SVG 节点的位置<br /> 元素的大小和其他的属性<br /> 所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。</p> <h2>状态动画与观察者</h2> <p>通过观察者我们能监听到任何数值属性的数值更新。可能听起来很抽象，所以让我们先来看看使用 Tweenjs 一个例子：</p> <pre><code class="lang-">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;&gt;&lt;/script&gt; &lt;div id=&quot;animated-number-demo&quot;&gt; &lt;input v-model.number=&quot;number&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; &lt;p&gt;{{ animatedNumber }}&lt;/p&gt; &lt;/div&gt; new Vue({ el: '#animated-number-demo', data: { number: 0, animatedNumber: 0 }, watch: { number: function(newValue, oldValue) { var vm = this function animate () { if (TWEEN.update()) { requestAnimationFrame(animate) } } new TWEEN.Tween({ tweeningNumber: oldValue }) .easing(TWEEN.Easing.Quadratic.Out) .to({ tweeningNumber: newValue }, 500) .onUpdate(function () { vm.animatedNumber = this.tweeningNumber.toFixed(0) }) .start() animate() } } }) </code></pre> </div>